1.awk
	线性文本处理工具
	可以在文本数据中进行字段分割和重组
	a.获取linux的IP地址
		ifconfig eth0 |grep Mask |awk -F " " '{print $2 }'|awk -F ":" '{ print $2}'
	b.打印所有的行
		 awk -F ":" '{ print }' /etc/passwd
	c.打印第一列
		查看系统中有哪些用户
		cut -d: -f1 passwd
		awk -F ":" '{ print $1 }' passwd
	d.打印多个列
		awk -F ":" '{print $1,$3}' passwd
		awk -F ":" '{print $1":"$3}' passwd
	e.把所有ssh登录失败的记录IP打印出来
		lastb -i|grep ssh |awk '{print $3}' |uniq -c
	f.打印每行的最后一列
		$NF 最后一列
		awk -F ":" '{ print $NF}' passwd | uniq -c
		/bin/bash  	用户可以登录系统进行操作
		/sbin/nologin 用户可以在系统中运行程序，但是不能登录
	g.打印每行的字段数(每行有多少列)
		NF 列的数量
		awk -F ":" '{ print NF }' passwd
	h.运算符
		+
		-
		*
		/
		%
		++
		--
		echo | awk '{ print 2^3}'
	i.关系运算符
		&&   逻辑与
		||   逻辑或
		!    逻辑非
	j.打印行号
		简单的条件判断NR代表行号
		awk -F ":" '{ print NR,$1}' passwd
		awk -F ":" 'NR==8{ print }' passwd
		原理:虽然打印的是第八行，但是前七行awk一样读取，只是没有打印
		打印字段数量大于6的行
		awk -F ":" 'NF>6{ print }' passwd
		打印uid在30-40之间额用户名
		awk -F ":" '$3>=10&&$3<=20{ print }' passwd
		隔行打印
		awk 'NR%2==0{ print }' passwd




a.终端设置：(~/.bashrc)
登录时候显示
1.当前用户为 xxx
2.当前IP为   xxx
3.当前主机名为 xxx


echo "当前用户是:" `whoami`
echo "当前IP是: "  `ifconfig eth0 |grep Mask |awk -F " " '{print $2 }'|awk -F ":" '{ print $2}'`
echo "当前主机名是: " `hostname`


b.系统情况报告
1.内存使用率超过80% 提示内存超标
2.磁盘使用率超过80% 提示磁盘超标
	获取 / 已用容量 a 总容量 b
	磁盘使用率 c=a/b
	80%==0.8
	判断 c是否大于0.8，提示
a=free -m |grep Mem|awk '{print $2}'
b=free -m |grep Mem|awk '{print $3}'
echo "scale=2;b/a" |bc

df -h |grep /$ |awk '{print $4}' |awk -F "%" '{print $1}'
2.awk的高级应用
	awk -F ":" 'BEGIN{处理文件前代码块}{处理文件中的代码块}END{处理文件后的代码块}'
	a.输出顶部增加come on baby，输出最后增加 get out of my face
		awk -F ":" 'BEGIN{ print "come on baby"}{print }END{print "get out"}' day2/passwd
	b.打印最后一行最后一列
		awk -F ":" 'END{ print $NF }' day2/passwd
	c.打印文件所有字段总数
		awk -F ":" 'BEGIN{ count=0 }{ count+=NF }END{ print count }' passwd
	d.打印字段数大于4的总行数
		 awk -F ":" 'BEGIN{ count=0}NF>4{ count++ }END{ print count}' passwd
	e.awk代码写入到独立的文件中
		文件名:01.awk
		BEGIN{
        FS=":"
        count=0
		}
		{
		        if ( NF>4 )
		        {
		                count++
		        }
		}
		END{
		        print count
		}
		程序执行 awk -f 01.awk passwd
	f.awk的函数调用
		print(参数)      打印完毕后会自动换行
		printf(参数)     格式化打印，定义格式，转义等等
		 echo |awk '{ printf("%d--%s\n",12,"simida")}'
	g.awk的循环
		for (i=0;i<0;i++){
			printf("%d",i)
		}
		文件名02.awk
		{
		for(i=0;i<5;i++)
		{
		        printf("%d",i)
		}
		}
		END{
		        print("over")
		}
		执行程序
		echo |awk -f 02.awk
	h.倒序排列所有字段
		文件名:test.txt
		1:2:3:4
		a:b:c:d:e:f
		处理后
		4:3:2:1
		f:e:d:c:b:a
		文件名:03.awk
		BEGIN{
        FS=":"
		}
		{
		        for(i=NF;i>0;i--)
		        {
		                if ( i>1 )
		                {
		                        printf("%s:",$i)
		                }
		                else
		                {
		                        printf("%s\n",$i)
		                }
		        }
		}
		执行程序
		awk -f 03.awk test.txt
2.sed 字段编辑和字段替换
	a.删除指令d
		删除所有行 sed -e 'd' passwd
		删除第一行 sed -e '1d' passwd
		删除1到3行 sed -e '1,3d' passwd
		删除第1行和第3行 sed -e '1d;3d' passwd
		包含root关键字行都被删除 sed -e '/root/d' passwd
		删除daemon开头的所有行   sed -e '/^daemon/d' passwd
		删除以nologin结尾的行    sed -e '/nologin$/d' passwd
		删除所有空行             sed -e '/^$/d' passwd
		删除所有以#开头的或者空行 sed -e '/^#/d;/^$/d' passwd
		删除以daemon开头的行到以shutdown结尾的行  sed -e '/^daemon/,/shutdown$/d' passwd
	b.直接保存结果到源文件中
		sed -i '/^root/d' passwd
	c.打印 p
		打印所有的行    sed -n -e 'p' passwd
		打印第一行和第三行 sed -n -e '1p;3p' passwd
		打印以b开头的行  sed -n -e '/^b/p' passwd
		打印以nologin结尾的行 sed -n -e '/nologin$/p' passwd
	d.替换
		把每行找到的第一个a替换为admin
			sed -e 's/a/admin/' passwd
		把每行找到的o都替换为admin
			sed -e 's/o/admin/g' passwd
		替换1-3行内容
			sed -e '1,3s/:/-/g' passwd
	e.使用域的方法进行定位
		 echo "03-23-2020" |awk -F "-" '{ print $3"-"$2"-"$1}'
		 echo "03-23-2020"|sed -r 's/(..)-(..)-(....)/\3-\1-\2/'
		 echo "come on,baby" | sed -r 's/(.*),(.*)/\2\1/'
		删除每行的第二个字符
		head -3 /etc/fstab |sed -r 's/(.)(.)(.*)/\1\3/'
		删除每行最后一个字符
		echo "can you see me?" |sed -r 's/(.*)(.)/\1/'




















